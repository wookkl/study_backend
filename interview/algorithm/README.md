# 알고리즘 인터뷰 질문

## 스택과 큐의 차이에 대하여 설명하세요.

스택: LIFO 구조로 가장 마지막에 삽입된 자료가 가장 먼저 삭제된다. 비어있는 스택에서 원소를 추출하려고 할때 stack underflow라고 하며, 스택이 넘치는 경우를 stack overflow라고 한다.  
예시: 웹 브라우저 방문기록, 수식의 괄호 검사, 후위 표기법 계산

큐: FIFO 구조로 가장 먼저 삽입된 원소가 가장 먼저 삭제된다.  
예시: 프로세스 관리, 우선순위가 같은 작업 예약

## 해시와 체이닝에 대하여 설명하세요.

### 해시와 해시함수

해시 함수는 데이터의 효율적인 관리를 위해서 길이가 각기 다른 데이터를 고정 길이로 매핑하는 함수이다.  
이 때 매핑하는 과정을 해싱이라고 한다. 매핑되기 전의 데이터를 키,(Key) 매핑 후의 데이터를 해시 값(Value)라고 한다.

### 해시의 목적

해시 테이블: 해시 값을 테이블 내의 주소로 이용하는 탐색 알고리즘으로, 이진 탐색보다 뻐르게 처리할 수 있다.  
암호화: 암호화에서 해시는 자주 사용된다. 어떤 값들을 해시로 변환하면 기존 값을 알아볼 수 없게 된다.  
이것 자체가 암호화에서 매우 유용하며, 이런 해시의 특성을 활용한 대표적인 알고리즘이 SHA(Secure Hash Algorithm)이다.  
데이터 축약: 길이가 다른 데이터를 일정한 길이로 축약시킬 수 있다. 방대한 양의 데이터를 해시로 줄일 수 있고 데이터 비교에 있어서도 축약한 것을 비교하는 것이 원본 데이터를 비교하는 것보다 빠른 성능을 보일 수 있다. 단, 데이터가 다름에도 해시된 값이 같은 경우가 생겨 충돌 가능성이 있다.

### 체이닝

충돌 해결 방법중에 하나이다. 점유된 슬롯을 피하지 않고, 점유된 슬롯에 어떻게든 자료를 추가하는 방식이다. 체이닝은 연결 리스트를 이용해서 구현한 방식이다.  
장점: 항복을 탐색하거나 저장, 삭제하고자 한다면, 계산한 해시 주소에 해당하는 연결 리스트에서 독립적으로 수행하기 떄문에, 오버 플로우가 발생해도 수행 시간 면에서 효율적이다.  
단점: 함수의 질적인 수준에 따라서 한 주소에 쏠림 현상이 있을 수 있다.

## 해시맵, 해시테이블에 대하여 설명하세요.

둘이 가장 큰 차이점은 동기화 보장 유무, 키와 값에 Null 가능 여부이다.  
동기화가 필요없다면 해시맵을 동기화 보장이 필요하다면 해시테이블을 사용한다.  
동가화 유무의 차이 외에는 거의 차이가 없다.  
멀티 쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성을 유지하기 위해 동기화가 필요하다.  
해쉬테이블의 동기화는 속도를 굉장히 느리게 해주기 때문에, 동기화가 보장되는 해시맵이 등장 -> ConcurrentHashMap

## 해시맵 충돌 해결방법은 무엇인가요.

1. 체이닝
2. 개방주소법
   - 선형조사: 충돌이 일어난 바로 다음 자리에 저장하는 방법 (제1 군집현상 발생)
   - 이차원조사: 충돌이 발생한 경우에 다음 데이터 자리를 이차 함수로 결정 제1 군집 현상 해결

## 퀵소트 머지소트 시간복잡도 설명하세요.

### 퀵소트

퀵소트는 평균적으로 nlogn의 시간복잡도를 가지지만, 최악의 경우는 n^2의 시간복잡도를 가진다. O(n^2)

**특징**

1. 랜덤배열에서 빠른 정렬 속도를 가진다.
2. pivot의 선정하는 방법에 따라서 속도가 달라진다.
3. 순열이나 역순의 경우에 매우 느린 속도를 보인다.

### 머지소트

머지소트는 O(nlogn)의 시간 복잡도를 가진다.

## 1부터 100까지 재귀 합을 구현해보세요.

```python
def sum_hunnit(n):
    if n == 0:
        return 0
    else:
        return sum_hunnit(n-1) + n
```

## pivotal(대각선이 고정인 행렬) 3x3, 4x4를 뒤집는 로직을 재귀 함수로 짜보세요.

```python
def pivotal(matrix, i, j):
    if len(matrix) == i or len(matrix) == j:
        return
    matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    if i + 2 == j:
        pivotal(matrix, i + 1, j)
    pivotal(matrix, i, j + 1)


n = int(input())
matrix = [[i + (j * n) + 1 for i in range(n)] for j in range(n)]
pivotal(matrix, 0, 0)
for i in board:
    print(i)

```
