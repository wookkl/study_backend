# 데이터베이스 인터뷰 질문

## RDB이 장단점은 무엇인지 말해보세요.

### 장점

- 명확하게 정의된 스키마, 데이터의 무결성을 보장한다.
- 관계는 각 데이터가 중복없이 한번만 저장된다.

### 단점

- 덜 유연하다. 데이터 스키마를 사전에 계획하고 알려야한다. (나중에 수정하기 힘들다.)
- 관계를 맺고 있어서 조인문이 복잡한 쿼리가 만들어질 수 있다.

## RDB 와 nosql의 장단점 및 차이점을 말해보세요.

### RBD

#### 장점

- 명확하게 정의된 스키마, 데이터의 무결성을 보장한다.
- 관계는 각 데이터가 중복없이 한번만 저장된다.

#### 단점

- 덜 유연하다. 데이터 스키마를 사전에 계획하고 알려야한다. (나중에 수정하기 힘들다.)
- 관계를 맺고 있어서 조인문이 복잡한 쿼리가 만들어질 수 있다.
- 대체로 수직으로 확장만 가능하다.

### nosql

#### 장점

- 스키마가 없어서 유연하다. 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가가 가능하다.
- 데이터는 애플리케이션이 필요로 하는 형식이 저장된다. 데이터를 읽어오는 속도도 빨라진다.
- 수직 및 수평 확장이 가능하다. 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리가 가능하다.

#### 단점

- 유연성으로 인해 데이터의 구조 결정을 미루게 될 수 있다.
- 데이터 중복을 계속 업데이트 해야 한다.
- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정시 모든 컬렉션에서 수행해야한다.

## RDBMS에서 R이 무엇을 의미하는지 설명하세요.

Relation. 관계를 뜻한다. 각 데이터가 관계를 가지고 있다.

## Natural Join도 함께 Cartesian Product를 설명하세요.

### Natural Join

- 두 테이블에 동일한 컬럼이 있다면 join 된다.

### Cartesian Product

- From절에 2개 이상의 Table이 있을때 두 Table 사이에 유효 join조건을 적지 않았을 때 해당 테이블에 대한 모든 데이터를 전부 결합하여 Table에 존재하는 행 갯수를 곱한 만큼의 결과값이 반환되는 것이다.

## DB 인덱스란 무엇인지 설명하세요.

### 개념

- 실제 데이터 레코드를 더 빠르게 탐색하기 위해서, 데이터 레코드를 참조하는 인덱스를 만들어 데이터 탐색을 빠르게 한다. `인덱스 - 데이터 레코드`로 구성이 된다. RDBMS에서 컴퓨터가 인덱스를 보고 해당 데이터를 빠르게 찾을 수 있게 되는 것이다.

### 특징

- 데이터 탐색을 빠르게 하는데 쓰인다.
- 정렬 되어있다.
- RDBMS에서 실제 데이터는 정렬이 되어 있을 수 있고, 안되어 있을 수 있다. 이는 Clustered 인덱스와 Nonclustered 인덱스로 나뉜다.
- 인덱스를 써서 탐색 속도가 올라간다면 모든 컬럼에 걸면 되지 않을까 라고 생각할 수 있다. 그러나, 새로운 데이터가 추가되거나 삭제될 떄 이에 대응하는 인덱스를 추가와 삭제를 해야 하기 때문에 RDBMS의 성능에 부담이 갈 수 있다.

### 사용해야 하는 상황

- tuple이 많이 들어있는 대용량의 relation
- relation에서 대부분의 쿼리가 검색하는 tupl이 2%~4%인 경우에는 사용하는 것이 좋다.
- 가능하면 한 relation에 세개 이하의 index를 만드는 것이 좋다.
- 파일의 레토드를 충분히 분할할 수 있어야한다.
- 가능하면 integer 속성에 인덱스를 만드는 것이 가장 좋고, 고정 길이 속성에 만드는 것도 좋다.
- 대량의 데이터를 삽입할 때는 모든 인덱스를 제거하고 데이터 삽입이 끝난 후에는 인덱스를 다시 생성하는 것이 좋다.

## DB 커넥션풀 만들면 좋은 점이 뭔지 말해보세요.

### 개념

- 서버는 동시에 사용할 수 있는 사람의 수라는 개념이 존재한다.
- 일반적인 커넥션 풀을 이용하면 동시 접속자 수를 넘어가게 될 경우에는 오류가 발생한다.
- 예외가 발생하면 그 접속자는 더이상 처리를 못하므로 다시 접속을 해야하는 불편함이 있다.
- 이를 위해 탄생한 것이 **커넥션 풀** 이다.
- 하지만 남아있는 커넥션 풀이란 동시 접속자가 가질 수 있는 커넥션을 하나로 모아놓고 관리한다는 개념이다.
- 누군가 접속하면 자신이 관리하는 풀에서 남아있는 커넥션을 제공한다.
- 하지만 남아있는 커넥션이 없을 경우에는 클라이언트를 대기 상태로 전환시킨다.
- 다시 커넥션이 풀에 들어오면 순서대로 커넥션을 제공한다.
- 즉, 데이터 베이스와 연결된 커넥션들을 풀에 저장해두고 있다가 필요할 떄 커넥션을 제공하는 기법이다.

### 정리

- 풀 속에 미리 커넥션이 생성되어 있기 때문에 커넥션을 생성하는데 드는 연결 시간이 소비되지 않는다.
- 커넥션을 계속해서 재사용하기 때문에 생되는 커넥션이 적다.
- 커넥션풀을 이용하면 커넥션을 생성하고 닫는 시간이 절약된다. 따라서, 어플리케이션의 실행 속도가 빨라진다. 또한, 한 번에 생성될 수 있는 커넥션 수를 제어하기 때문에 동시 접속자 수가 몰려도 웹 어플리케이션이 쉽게 다운되지 않는다.

## INNER JOIN, OUTER JOIN 설명 및 차이점에 대해 말해보세요.

### INNER JOIN

둘 이상의 테이블을 조인 조건에 맞는 행만 반환한다. 즉, 둘 이상의 테이블에 전부 존재하는 데이터만 조회한다는 것이다.

### OUTER JOIN

LEFT, RIGHT, FULL OUTER JOIN이 있는데 INNER JOIN들과 달리 두 테이블에서 지정된 쪽으로 반대값과 매칭이 되든 안되는 모든 결과를 반환한다. 매칭이 안되는 부분은 NULL로 채워진다.

## n+1 쿼리문제에 대해 말해보세요.

### 개념

A엔티티와 B엔티티가 1:N관계일 때, 1개의 A 엔티티를 조회할 때마다 A에 참조되고 있는 N개의 B엔티티가 N개의 독립적인 쿼리에 의해 조회되는 현상이다.

### 문제가 되는 이유

A 엔티티와 A 엔티티를 참조하고 있는 N개의 B 엔티티 모두를 1개의 쿼리로도 조회를 할 수 있는데 A 엔티티 조회 1번 + B 엔티티 조회 N번으로 N번의 조회가 더 실행되기 떄문에 조회 속도가 늦어지게 된다.

## Django N+1 쿼리 해결방법

- select_related() 또는 prefetch_related()를 통해 쿼리를 날려준다.

## union 쿼리에 대해 말해보세요.

- UNION 쿼리는 두 개 이상의 테이블 행을 합칠 때 사용하는 연산자이다. 이는 두 개 이상의 SELECT문의 결과 값을 합치는 것을 의미한다. 조건절에 따라 일부만 합칠 수도 있다. 연산자를 사용할 때 SELECT문의 열 개수와 데이터 타입이 일치해야 한다. 중복된 값을 보여주고 싶다면 UNION ALL을 사용한다.

## DB 실행계획에 대해 말해보세요.

### 실행계획이란?

- DBMS의 쿼리 실행 에 같은 결과를 만들어 내는 한가지 방법만 있는 것이 아니다.
- 아주 많은 방법이 있지만 각 처리 방법마다 성능은 서로 다를 수 있기 때문에 그 중에서 어떤 방법이 최악이고 최선인지 결정해야 한다.

### 최적의 실행을 결정하는 방법

- DBMS에서는 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 자장되어 있는지 "통계 정보"를 참조한다.
- DBMS의 옵티마이저는 그러한 기본 데이터를 비교해 "최적의 실행 계획"을 수립하는 작업을 한다.
- 하지만 실행계획은 통계 자료 값을 기반으로 옵티마이저가 선택한 "예상치"이기 때문에 실제 수행할 때에는 I/O 또는 시간차이가 날 수 있고 결과 값도 다를 수 있다.

## 트랜잭션에 대해 설명해보세요.

### 개념

트랜잭션은 데이터베이스 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 수행되어야 할 일련의 연산들을 의미한다.

### 특징

- 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다.
- 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다.
- 하나의 트랜잭션은 커밋 또는 롤백 된다.

### 성질

- Atomicity(원자성): 트랜잭션 연산은 모두 반영되거나 모두 반영되지 않아야 한다.
- Consistency(일관성): 트랜잭션이 성공적으로 완료되면 언제나 일관성있는 데이터베이스 상태로 변환한다.
- Isolation(독립성): 둘 이상의 트랜잭션이 동시에 실행되는 경우 어느 하나의 트랜잭션이 실행중에 다른 트랜잭션의 연산을 끼어들 수 없다.
- Durablility(영속성, 지속성): 성공한 트랜잭션은 데이터베이스 시스템이 고장나도 영구적으로 반영되어야 한다.

## 클러스터 인덱스, 논클러스터 인덱스 차이에 대해 말해보세요.

### 클러스터 인덱스

- 테이블의 데이터를 지정된 컬럼에 대해 물리적으로 재배열한다.
- 데이터 삽입, 삭제시 테이블의 데이터를 정렬시킨다.
- 테이블 당 한개만 존재한다.
- 테이블에서 인덱스를 걸면 가장 효율적일 것 같은 컬럼은 클러스터 인덱스로 지정
- 테이블에 데이터가 많이 저장된 상테에서 ALTER를 통해 클러스터 인덱스를 추가하면, 많은 데이터를 정렬해야 하므로 리소스를 많이 차지하게 된다.

### 논클러스터 인덱스

- 테이블에 데이터를 지정된 컬럼에 대하여 물리적으로 재배열하지 않는다.
  단지 지정된 컬럼에 대해 정렬시킨 인덱스를 만든다.
- 테이블당 여러 개 존재하능하다.

## DB 클러스터링과 리플리케이션의 차이점에 대해 말해보세요.

### DB 클러스터링

- 데이터베이스는 DB서버와 저장소를 각각 데이터 분류로 확인한다.
- DB서버는 계산이나 업무로직을 담당한다. 저장소는 데이터 보존의 기능을 담당한다.

#### 기본적인 다중화 구조

- DB 서버 1대, 2대가 있다고 한다면, 이 DB 서버 2대는 1개의 저장소를 관리하고 있다. 여기서 'Active-Active'와 'Active-Standby'로 나뉜다.

**Active-Active**: 클러스터를 구성하는 컴포넌트를 동시에 가동한다.

1. 장점

   - 시스템 다운 시간이 짧다.
   - 성능이 좋다.

2. 단점
   - 병목되는 경우가 있다.

**Active-Standby**: 클러스터를 구성하는 컴포넌트중에 Active가 실제로 가동되고, 남은 것은 대기(Standby)한다.
Active에서 시스템 장애가 생길 경우 Standy로 전한되는데 시간이 걸리게 된다. 그 사이에 시스템은 다운 상태가 된다.

### 리플리케이션

클러스터 구성에서는 서버는 다중화할 수는 있어도 저장소는 다중화를 하지 못하므로, 저장소 부분이 터지게 된다면 큰 위험을 초래할 수 있기 때문에 리플리케이션을 하게 된다.

#### 주의할 점

1. Active측 저장소의 데이터는 항상 사용자로 부터 갱신되기 떄문에 Standby측에도 데이터를 동기화 해야한다.
2. 갱신 주기를 얼마로 할 것과 성능에 관하여 트레이드 오프가 발생한다.
