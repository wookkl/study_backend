# 분류하지 못한 인터뷰 질문들

## 소프트웨어 공학이 나온 배경에 대해 말해보세요.

## 객체지향 언어의 3대 특징에 대하여 설명하세요.

### 추상화

- 추상화라고 하는 것은 객체들의 공통적인 특징(속성과 기능)을 뽑아내는 것이다.
- 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다.
- 추상화는 절차지향 프로그래밍에서 있었다. 대표적인 것이 구조체같은 사용자 데이터형같은 것이다.
- 데이터를 추상화하여 하나의 새로운 데이터 유형을 만드는 것이다.

### 캡술화

- 객체지향에서 캡슐화는 데이터 구조와 데이터 다루는 방법을 결합하여 묶는 것이다.
- 특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶어 관리한다.
- 객체가 맡은 역할을 수행하기 위한 하나의 목적을 위해 데이터와 기능들을 묶는것이다.
- 또한, 데이터를 은닉하고 그 데이터를 접근하는 기능을 노출시키지 않는다는 의미로도 사용된다.

### 상속성

- 상속이 없으면, 객체지향은 절차지향과 별 다른 바 없다.
- 상속이란 특징을 가지면서 객체지향의 언어가 절차지향 언어의 비해 문법 규모가 2배이상 늘어났다.
- 상속이란 상위 개념의 특징들을 하위 개념이 물려받는 것을 말한다. 하나의 클래스가 가지고 있는 특징 들을 그대로 다른 클래스가 물려주고자 할 떄 상속성의 특징을 활용헌다.

### 다형성

- 다형성의 의미는 약간 다른 방법으로 일을 하는 함수를 동일한 이름으로 호출해주는 것을 말한다.

## 프레임워크와 라이브러리에 대해 말해보세요.

### 프레임워크

- 뼈대를 뜻하고, 제어 역전 개념이 적용된 대표적인 기술이다. 소프트웨어 프레임워크는 '소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합'이라 할 수 있다. 완성된 애플리케이션이 아닌 개발자가 완성시키는 작업을 해야한다.
- 객체 지향 개발을 하게 되면서 통합성, 일관성의 부족으로 발생되는 여러가지 문제들을 해결할 방법중 하나라고 할 수 있다.

#### 특징

- 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성되어 있다.
- 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.
- 컴포넌트들은 재사용이 가능하다.
- 높은 수준의 패턴들을 조직화할 수 있다.

### 라이브러리

- 단순 활용 가능한 도구들을 말한다. 즉, 개발자가 만든 클래스에서 호출하여 사용, 클래스들의 나열로 필요한 클래스를 불러서 사용하는 방식을 말한다.

### 차이점

- 제어 흐름에 대한 주도성이 누구에게/어디에 있는가에 있다. 즉, 애플리케이션의 흐름을 누가 쥐고 있느냐에 달려있다.
- 프레임워크는 전체적인 흐름을 스스로가 쥐고 있으며 사용자는 그 안에서 필요한 코드를 짜 넣으며 반면에 라이브러리는 사용자가 전체적인 흐름을 만들어 라이브러리를 가져다 쓰는 것이다.

## soa에 대해 설명하세요.

### 개념

- SOA(Service Oriented Architecture)란 기존의 애플리케이션의 기능들을 비즈니스적인 의미를 가지는 기능 단위로 묶어서 표준화된 호출 인터페이스를 통해서 서비스라는 소프트웨어 컴포넌트 단위로 재조합한 후, 이 서비스들을 서로 조합하여 업무 기능을 구현한 애플리케이션을 만들어내는 소프트웨어 아키텍쳐이다.
- 기존의 시스템에 각각의 독립된 업무 시스템으로 개발되었던 반면 SOA는 기업의 전체 엄무가 하나의 거대한 SOA시스템으로 구성된다.
- 새로운 업무를 구현할 때 새롭게 시스템을 신규 개발하는 것이 아니라 이미 제공되어 있는 기존의 서비스들으 조합하여 하나의 업무를 구현할 수 있다. 소프트웨어의 재사용성과 레고웨어의 연장선이다.

**정리**: 각각의 시스템의 기능들을 업무 기준으로 주요 기능들을 묶어서 플랫폼에 독립적인 인터페이스를 구현하여 외부로 서비스를 제공한다.

### 탄생 이유

- 급격한 비즈니스 환경의 변화에 따라 비즈니스 요구를 민첩하게 IT시스템에 반영해야 하는 필요성이 생겼고, 각 업무별로 독립된 시스템의 형태로 개발되어 있는 업무 시스템들을 통합하기 위해 SOA가 대두되었다.

## Elastic Search에 대해 설명하세요.

### 개념

- Apache Lucene(아파치 루씬)기반의 Java 오픈소스 분산 검색 엔진이다.
- Elastic Search를 통해 루씬 라이브러리를 단독으로 사용할 수 있게 되었으며, 방대한 양의 데이터르 신속하게, 거의 실시간(NRT, Near Real Time)으로 저장, 분석, 검색할 수 있다.
- Elasticsearch라는 검색을 위해 단독으로 사용되기도 하며, ELK(Elasticsearch, Logstash, Kibana)스택으로 사용되기도 한다.

#### ELK

- Logstatsh: 다양한 소스(DB, CSV)의 로그 또는 트랜잭션 데이터를 수집, 집계, 파싱하여 Elasticsearch로 전달한다.
- Elasticsearch: Logstatsh로부터 받은 데이터를 검색 및 집계를 하여 필요한 관심있는 정보를 획득한다.
- Kibana: Elasticsearch의 빠른 검색을 통해 데이터를 시각화 및 모니터링한다.

## 도커 컨테이너와 VM의 차이점은 뭔가요?

### Virtual machine

- "하이퍼바이저"를 통해 물리적 기계 위에서 돌아간다. 한편 하이퍼바이저는 호스트 머신이나 베어메탈(소프트웨어가 전혀 담겨있지 않은)위에서 실행된다.

**하이퍼바이저**: VM이 실행되는 소프트웨어나 펌웨어, 혹은 하드웨어를 뜻한다. 하이퍼바이저들은 호스트 머신이라 불리는 물리적 기계 위에서 돌아가고, 호스트 머신은 VM에 램과 CPU등에 자원을 제공한다.

#### Bare metal Hypervisor

- 하드웨어 바로 위에 위치하며, 호스트 하드웨어에 직접 설치하여 구동한다.
- 하드웨어를 제어하는 OS역할과 VM을 관리하는 역할을 모두 하이퍼바이저가 담당한다.

#### Hosted Hypervisor

- 호스트 OS 위에 설치되는 방식의 하이퍼바이저이다. 즉, 컴퓨터의 기존 환경을 그대로 사용하는 방식으로, 설치 구성이 편리하다.

### 컨테이너

하드웨어에서 가상화하는 VM과 달리, 컨테이너는 유저 공간의 추상화를 통해 운영체제 레벨의 가상화를 제공한다. 컨테이너도 VM처럼 프로세싱을 위한 별도의 공간(private space), 루트 권한, 사설 네트워크, IP주소, 커스텀 라우트 등의 기능을 갖추고 있다.  
하지만 컨테이너는 호스트 시스템의 커널을 다른 컨테이너와 공유한다는 점에서 크게 차이가 난다.

컨테이너는 유저 공간만을 포함하고, 커널이나 가상 하드웨어가 포함되지 않는다. 여러개의 컨테이너가 하나의 호스트 머신에서 돌아갈 수 있도록 각 컨테이너는 자신만의 격리된 유저 공간을 가지고 있다. 즉, 운영체제 단계의 아키텍쳐를 모든 컨테이너가 공유하고 있다는 것이다. 처음부터 새로 생성되는 부분은 bins와 libs뿐이다. 이것이 컨테이너가 가벼워질 수 있는 이유이다.

### 도커

- 도커는 리눅스 컨테이너를 기반으로 하는 오픈소스 프로젝트이다. 네임스페이스, 컨트롤 그룹과 같은 리눅스 커널 기능을 이용해서 운영체재 위에 컨테이너들을 생성하는 것이다.

#### 특징

- 간단한 사용법: 도커는 개발자, 시스템 관리자, 아키텍트 등 누구든지 컨테이너 이점을 활용해서 손쉽게 이동성있는 애플리케이션을 생성, 테스트할 수 있도록 만들어졌다.
- 속도: 도커는 매우 가볍고 빠르다. 컨테이너는 커널에서 돌아가는 샌드박스화된 환경일 뿐이어서, 더 적은 자원을 소비한다.
- 도커 허브: 도커 허브는 일종의 도커 생태계로 유저들이 자유롭게 사용할 수 있다. 커뮤니티에 의해 생성되어 바로 사용가능한 도커 이미지들이 있고, 약간의 수정 또는 수정없이 바로 사용할 수 있다.
- 모듈성, 확장성: 도커는 애플리케이션의 기능들을 각각 컨테이너들로 쉽게 분리할수 있도록 해준다. 컨테이너들을 연결하여 애플리케이션을 만들 수 있다. 각각의 컴포넌트에 대해서 업데이트하거나 스케일링하기 쉬워진다.

### 차이점 정리

> 가상머신은 운영체제 위에 하드웨어를 에뮬레이션하고 그 위에 운영체제를 올리고 프로세스를 실행하는 반면에, 도커 컨테이너는 하드웨어 에뮬레이션 없이 리눅스 커널을 공유해서 바로 프로세스를 실행한다
